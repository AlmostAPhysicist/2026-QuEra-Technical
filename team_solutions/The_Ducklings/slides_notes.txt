================================================================================
         QUANTUM ERROR CORRECTION: [[7,1,3]] COLOR CODE
                 The Ducklings Implementation Guide
================================================================================

TABLE OF CONTENTS
=================
1. WHY QUANTUM ERROR CORRECTION?
2. THE [[7,1,3]] COLOR CODE
3. STEANE ERROR CORRECTION
4. QUERA'S MAGIC STATE DISTILLATION CIRCUIT
5. MODULE STRUCTURE
6. RUNNING THE CODE
7. ADVANCED TOPICS & NEXT STEPS
8. QUICK REFERENCE

================================================================================
PART 1: WHY QUANTUM ERROR CORRECTION?
================================================================================

THE FUNDAMENTAL PROBLEM
=======================

Classical vs Quantum Information:

CLASSICAL:
  - Bit is 0 or 1, well-defined
  - If noise flips it: 001 → 011, majority vote recovers original
  - Simple to protect via duplication
  
QUANTUM:
  - State is superposition: |ψ⟩ = α|0⟩ + β|1⟩
  - Coefficients α, β encode the information
  - Two critical problems:

Problem 1: NO-CLONING THEOREM
  - You CANNOT copy an arbitrary unknown quantum state
  - If you could clone |ψ⟩ → |ψ⟩ ⊗ |ψ⟩, then:
    - |0⟩ → |0⟩ ⊗ |0⟩
    - |1⟩ → |1⟩ ⊗ |1⟩
    - But (|0⟩ + |1⟩) → ? (CONTRADICTION!)
  - Cannot simply duplicate qubits like classical bits

Problem 2: DECOHERENCE
  - Qubits naturally lose information:
    - T1 relaxation: |1⟩ → |0⟩ (spontaneous decay)
    - T2 dephasing: relative phases get lost
    - Gate errors: imperfect operations introduce Pauli flips (X, Y, Z)
    - Measurement errors: reading qubits introduces errors
  - Combined: quantum information corrupts faster than we can compute

THE SOLUTION: DISTRIBUTE, DON'T DUPLICATE
===========================================

Key Insight: Spread quantum information non-locally across multiple qubits:

1. DISTRIBUTE INFORMATION
   - 1 logical qubit → 7 physical qubits
   - No single physical qubit holds all the information
   - If one flips: many stabilizer parities change slightly

2. MEASURE WITHOUT COLLAPSING
   - Use auxiliary qubits ("probes") to check parity constraints
   - These extract error information WITHOUT revealing the logical state
   - Data qubits remain undisturbed for further rounds

3. DECODE & CORRECT CLASSICALLY
   - Compare syndromes before/after error
   - Use lookup table: syndrome pattern → error location + type
   - Apply opposite Pauli to flip error back
   - Verify by remeasuring syndromes

WHY THIS WORKS
==============
- Each single-qubit error produces UNIQUE syndrome flip pattern
- Syndrome patterns are "non-local" (depend on multiple qubits)
- One physical qubit flip changes MULTIPLE syndrome parities
- Classical algorithm can uniquely identify which qubit was hit
- Correction applies opposite Pauli to cancel the error

================================================================================
PART 2: THE [[7,1,3]] COLOR CODE
================================================================================

UNDERSTANDING CODE NOTATION: [[n, k, d]]
========================================

n = 7:    Number of physical qubits
k = 1:    Number of logical qubits encoded (we store 1 logical qubit)
d = 3:    Minimum distance

Distance explains error-correcting capability:
  - Distance 3: correct all single-qubit errors (X, Y, or Z on any qubit)
  - Cannot correct two-qubit errors (but they're exponentially rarer)
  - Generally: distance d corrects ⌊(d-1)/2⌋ errors

THE COLOR CODE GEOMETRY
=======================

The color code is defined on a 2D checkerboard lattice with three colors:
RED, GREEN, BLUE

Each color defines a stabilizer (a parity check):

RED STABILIZER:    qubits [2, 3, 4, 6]
  Measures: even/odd parity of (q2, q3, q4, q6) measurements
  If measurement result is |0⟩ or |1⟩, check: measurement count mod 2
  Result: +1 (even parity) or -1 (odd parity)

GREEN STABILIZER:  qubits [1, 2, 4, 5]
  Measures: even/odd parity of (q1, q2, q4, q5) measurements

BLUE STABILIZER:   qubits [0, 1, 2, 3]
  Measures: even/odd parity of (q0, q1, q2, q3) measurements

UNDERSTANDING SYNDROMES
=======================

A syndrome is a parity measurement:

  Procedure:
    1. Measure which physical qubits are in state |1⟩
    2. For each stabilizer, XOR the results of its constituent qubits
    3. Result: +1 (even parity) or -1 (odd parity)

Why Syndromes Matter:
  - Each single-qubit error produces a UNIQUE syndrome flip pattern
  - Compare syndromes before error (baseline) and after error
  - The CHANGE in syndromes pinpoints the error location
  - This is classical information; quantum state is preserved

EXAMPLE: X-ERROR ON QUBIT 4
============================

Initial state: |ψ_L⟩ with syndromes (1, 1, -1)

After X error on qubit 4:
  - RED syndrome [2,3,4,6] includes qubit 4 → parity FLIPS
  - GREEN syndrome [1,2,4,5] includes qubit 4 → parity FLIPS
  - BLUE syndrome [0,1,2,3] does NOT include qubit 4 → parity STAYS SAME

Syndrome change: (R, G, B) = (flip, flip, no-flip) = (1, 1, 0)

Lookup in SYNDROME_TABLE:
  (1, 1, 0) → qubit 4

Algorithm then applies X on qubit 4 to cancel the error.

================================================================================
PART 3: STEANE ERROR CORRECTION
================================================================================

THE COMPLETE 7-STEP WORKFLOW
=============================

STEP 1: ENCODING
  |ψ⟩ ──[QuEra MSD Circuit]──> |ψ_L⟩

  - Prepare physical state |ψ⟩ on qubit 6 using Rz(θ) Rx(φ) |0⟩
  - Apply 8-layer MSD injection circuit
  - Result: 7-qubit encoded logical state |ψ_L⟩
  - Information is now distributed across all 7 qubits

STEP 2: BASELINE SYNDROME MEASUREMENT
  |ψ_L⟩ ──[Measure X syndrome]──> (R_x, G_x, B_x)
           [Measure Z syndrome]──> (R_z, G_z, B_z)

  - Prepare two auxiliary logical qubits (probes):
    * X-syndrome probe: |+_L⟩ (eigenstate of X operator)
    * Z-syndrome probe: |0_L⟩ (eigenstate of Z operator)
  - Entangle data ↔ probes via transversal CNOT
  - Measure probes to extract syndrome parities
  - CRUCIAL: Data qubits NOT measured; state |ψ_L⟩ remains intact
  - These measurements are the "reference" for later comparison

STEP 3: ERROR INJECTION (SIMULATED)
  |ψ_L⟩ ──[Inject Pauli on qubit i]──> |ψ_L, error⟩

  - Apply a known Pauli (X, Y, or Z) to demonstrate the pipeline
  - In real scenarios, errors occur randomly
  - Here we inject deterministically for testing

STEP 4: SYNDROME MEASUREMENT AFTER ERROR
  |ψ_L, error⟩ ──[Measure X syndrome]──> (R_x', G_x', B_x')
                  [Measure Z syndrome]──> (R_z', G_z', B_z')

  - Repeat syndrome measurement with error present
  - Use fresh probes

STEP 5: CLASSICAL DECODING
  Syndrome flip patterns:
    ΔR = 1 if R_x' != R_x, else 0
    ΔG = 1 if G_x' != G_x, else 0
    ΔB = 1 if B_x' != B_x, else 0
  
  Similarly for Z syndromes.

  Lookup in SYNDROME_TABLE:
    (ΔR, ΔG, ΔB) → qubit location
    (ΔR_z, ΔG_z, ΔB_z) → qubit location (for Z errors)
  
  Classify error type:
    - If both X and Z syndromes flip at same qubit → Y error
    - If only X syndrome flips → X error
    - If only Z syndrome flips → Z error
    - If neither flips → no error (or uncorrectable multi-qubit error)

STEP 6: CORRECTION
  |ψ_L, error⟩ ──[Apply correction Pauli]──> |ψ_L⟩ (hopefully!)

  - Apply opposite Pauli to cancel the error
  - If error was X on qubit 4, apply X on qubit 4
  - If error was Y on qubit 4, apply Y on qubit 4
  - If error was Z on qubit 4, apply Z on qubit 4
  - If no error detected, apply nothing

STEP 7: VERIFICATION
  Corrected state ──[Measure syndromes]──> (R_x'', G_x'', B_x'')
                                            (R_z'', G_z'', B_z'')

  - Measure syndromes again
  - Compare to baseline (step 2)
  
  If syndromes match baseline:
    ✓ Correction successful
    ✓ Error was flipped back to identity
    ✓ Logical state |ψ_L⟩ is recovered (or destroyed if uncorrectable)
  
  If syndromes don't match:
    ✗ Correction failed
    ✗ Uncorrectable error occurred
    ✗ Cannot recover logical information

================================================================================
PART 4: QUERA'S MAGIC STATE DISTILLATION CIRCUIT
================================================================================

THE 8-LAYER ENCODING STRUCTURE
===============================

The MSD (Magic State Distillation) circuit is QuEra's injection method
that encodes one physical qubit into a 7-qubit logical block.

INPUT:  6 |0⟩ qubits (ancillas) + 1 |ψ⟩ qubit (input)
OUTPUT: 7 qubits in |ψ_L⟩ (distributed logical state)

Layer 1: √Y† on qubits 0-5
  Prepares ancillas in special basis for entanglement

Layer 2: CZ entanglement (qubits 1-2, 3-4, 5-6)
  Creates pairs of entangled qubits

Layer 3: √Y on qubit 6
  Rotates input qubit

Layer 4: Long-range CZ (qubits 0-3, 2-5)
  Couple distant qubits across the block

Layer 5: CZ(qubit 4, qubit 6)
  Connect input qubit to the core block

Layer 6: √Y on qubits 2-6
  Further entanglement

Layer 7: Final CZ layer (qubits 0-1, 2-3, 4-5)
  Complete the entanglement pattern

Layer 8: √Y on qubits 1, 2, 4
  Final state preparation

The circuit achieves:
  1. Distributes information from qubit 6 across all 7 qubits
  2. Creates stabilizer eigenstates (enables syndrome measurement)
  3. Preserves logical information (reversible via exact inverse)

THE DECODER
===========

Decoding = exact inverse of encoding:
  - Apply layer 8 inverse, then layer 7 inverse, etc.
  - In noiseless setting: perfectly recovers original state on qubit 6
  - In noisy setting: measure syndromes BEFORE decoding, apply correction

================================================================================
PART 5: QUICK REFERENCE
================================================================================

STATE ENCODING (Bloch Angles)
=============================
zeroState()  → (0,     0)    |0⟩
oneState()   → (0,     π)    |1⟩
plusState()  → (0,   π/2)    |+⟩
minusState() → (π,   π/2)    |-⟩

PAULI ERROR ENCODING
====================
basis=0  →  X error (bit-flip)
basis=1  →  Y error (bit-flip + phase-flip)
basis=2  →  Z error (phase-flip)

SYNDROME TABLE: Flip Pattern → Qubit
====================================
(0, 0, 0) → -1  (no error)
(0, 0, 1) → 0
(0, 1, 1) → 1
(1, 1, 1) → 2
(1, 0, 1) → 3
(1, 1, 0) → 4
(0, 1, 0) → 5
(1, 0, 0) → 6

STABILIZER SUPPORTS
===================
RED   = [2, 3, 4, 6]
GREEN = [1, 2, 4, 5]
BLUE  = [0, 1, 2, 3]

QUBIT LAYOUT
============
Qubits 0-5: Ancillas (prepared in |0⟩)
Qubit 6:    Input (carries state |ψ⟩)

After encoding: Information distributed across all 7 qubits

================================================================================
PART 6: MODULE OVERVIEW
================================================================================

states.py → Bloch angle helpers (zeroState, oneState, plusState, minusState)
encoding.py → MSD circuit: setPhysicalQubit, encode_713_block, decode_713_block
errors.py → inject_pauli for error simulation
error_mapping.py → Stabilizers, parities, classical syndrome decoder
syndrome.py → Quantum kernels for syndrome measurement & verification
logical_ops.py → logical_X_roundtrip experiment
correction.py → run_full_QEC: complete pipeline (7 steps)
experiments.py → run_noiseless, run_with_noise, post-selection, sweeps

================================================================================
PART 7: EXAMPLE OUTPUT
================================================================================

Running: run_full_QEC(zeroState()[0], zeroState()[1], err_index=4, err_basis=1)
        (Inject Y error on qubit 4)

Expected Output:
================
======================================
Injected error: Y on qubit 4
======================================
Baseline X syndrome: (1, 1, 1)
Baseline Z syndrome: (1, 1, -1)

After error injection:
X syndrome: (-1, -1, 1)
Z syndrome: (-1, -1, -1)

Detected error: Y on qubit 4

After correction:
X syndrome: (1, 1, 1)
Z syndrome: (1, 1, -1)

[SUCCESS] Correction successful.

Interpretation:
  - Baseline syndromes establish reference (depend on input state |0⟩)
  - X syndrome flips in R, G components → X-type error on qubit 4
  - Z syndrome flips in R, G components → Z-type error on qubit 4
  - Both flip → Y error (Y = iXZ has both X and Z characteristics)
  - After correction, syndromes match baseline → Error successfully removed

================================================================================
PART 8: NEXT STEPS
================================================================================

1. MULTIPLE ROUNDS
   - Measure → decode → correct → measure again
   - Better error accumulation modeling

2. POST-SELECTION
   - Accept only shots with trivial syndrome
   - Improves fidelity at cost of data loss

3. LARGER CODES
   - Distance 5 ([[25,1,5]]) corrects 2-qubit errors
   - Distance 7 ([[49,1,7]]) corrects 3-qubit errors

4. NOISE CHARACTERIZATION
   - Sweep physical error rate
   - Find QEC threshold
   - Characterize dominant error channels

5. HARDWARE INTEGRATION
   - Integrate Gemini noise model
   - Run on real hardware or Tsim
   - Validate against platform-specific noise

================================================================================
End of Documentation
================================================================================

Slide 12 - Code & Repro
- `python team_solutions/The_Ducklings/run_demo.py`
- Repo: forked and PR submitted
